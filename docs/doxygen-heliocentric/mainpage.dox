/**
\mainpage

Heliocentric is a 3D game engine written in C++, based OpenGL 3.0. This page 
will show how to get started.

Heliocentric provides a number of things:

- a game loop
- window management
- a scenegraph

# Major changes

A simple lighting model was added. It seems that some things are not correct yet,
but it is hard to verify this without a proper scene to test it on. Perhaps it
is just a case of tweaking parameters. However, it does seem like the gamma 
correction is incorrect.

`GameInterface` has new members `windowResized` and `windowClosed` and its the 
name of its member `shouldstop` has been corrected to `shouldStop`. This breaks 
current code, albeit very easy to fix.

The class `RenderManager` has been added, making Heliocentric a lot easier to 
work with. Note that this class may undergo strong, possibly code-breaking 
modifications, see section 5 below.

Added `GameAdaptor` as a convenient alternative to `GameInterface`, see section 
1 below.

# Getting started

To make a 3D game with Heliocentric, all that needs to be done is to implement a number of hooks. 
These hooks are provided by the interfaces `GameInterface` ~~and `InputListener`~~. 
Additionally it can take care of rendering objects if its scenegraph is populated.

## 1. %GameInterface
The first step is to implement a subclass of `GameInterface`. This interface
provides the hooks in the game loop:

- `init`
- `update`
- `renderWorld`
- `renderHUD`
- `shutdown`
- `shouldStop`
- `windowResized`
- `windowClosed`

See the `GameInterface` documentation for a description of where those hooks are
for. Some tips:

- Create a persisting instance of `RenderManager` in `init`,
- load meshes and create initially present game objects in `init`,
- add those objects to the scene graph via `RenderManager` in `init`,
- do input handling and physics updates in `update`,
- call `RenderManager::render` in `renderWorld`.

An alternative to `GameInterface` is `GameAdaptor`, which is an empty 
implementation of `GameInterface`. This may be more convenient if many 
functions are left empty.

## 2. Input handling
_This will be completely overhauled in the next update, so just don't bother yet._

## 3. Running your game

An instance of `Game3D`, the core class of the engine, must be created. This 
class provides a method `run` that starts the game-loop.

The code-fragment below starts a game based on Heliocentric, where it is assumed
the subclass of `GameInterface` is called `MyGame` and the subclass of 
`InputListener` is called `MyInputListener`.


\code

    int main(int argc, char** argv) {
	    MyGame myGame;
	    MyInputListener myListener;
    
        Game3D game(myGame);
        game.setInputListener(&myListener);
        game.run();
    
        return 0;
    }
\endcode

## 4. The scene graph

All objects in the scene graph will automatically be rendered when 
`game->getScenegraph().render(base)` is called, which must be done in the
`renderWorld` method of the `GameInterface` implementation.

To allow an object to be rendered by the scene graph, a number of things must be 
done:

1. the object must be a subtype of `GameObject`,
2. a renderer must be provided,
3. a shader program must be provided for the renderer,
4. a mesh must be loaded,
5. a node must be registered to the scene graph.

All of your game-objects should be a subtype of `GameObject`, such that the 
scene-graph can poll the object's position and orientation to draw the graphical 
representation of the object correctly.

Heliocentric provides a renderer called `DefaultRenderer`. All you need to do is
to instantiate it once: all spatials in the scene graph can use the same renderer.
If this renderer does not suit your needs, you can create your own by implementing
a subclass of `MeshRenderer`.

The graphical representation of your game-object is defined by a mesh (and in 
later versions of heliocentric additionally by textures). Heliocentric provides 
a mesh-loader for meshes defined by a Wavefront .obj file.

Finally you need to create the node for the scene graph and register it. 
Most often you will use a node of the type `Spatial`. The code fragment below 
shows an example of how all of this is done.
This code example uses shaders provided by Heliocentric and assumes the `Game3D`
instance is available as the variable `game`.

\code

	// Only once
	vector<string> attributes;
	attributes.push_back("position");
	ShaderProgram program("data/shaders/solid.vert",
			"data/shaders/solid.frag", &attributes);
	DefaultRenderer renderer(program);

	// For each object
	MyObject obj; // MyObject is a subclass of GameObject
	Mesh* mesh = loaders::loadOBJ("path/to/mesh.obj");
	Spatial node(renderer, *mesh, obj);
	game->getScenegraph().addChild(node);
\endcode

Note that steps 2, 3 and 5 can be simplified by using `RenderManager`. Example
code for this is shown below. Also note that both of these examples cannot be 
used as-is, because of data persistence.

\code

	// Only once
	RenderManager manager(game);
	
	// For each object
	MyObject obj; // MyObject is a subclass of GameObject
	Mesh* mesh = loaders::loadOBJ("path/to/mesh.obj");
	manager.addToSceneGraph(obj, *mesh);
\endcode

## 5. %RenderManager
The class `RenderManager` provides shortcuts for various actions:

- creating renderers and shaders,
- updating properties required by the shaders,
- adding objects to the scene graph,
- memory management for all of the above.

Most notably, by default `RenderManager` creates a renderer, which is used for 
game objects added to the scene graph via `RenderManager::addToSceneGraph(GameObject&, Mesh&)`.
Make sure to read the docs to know what `RenderManager` can do for you. 
Take a look at `setLightingProperties` and `addToSceneGraph` in particular.


# Class diagram
\image html "heliocentric class diagram.png"

*/